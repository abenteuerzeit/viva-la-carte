// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using VLC.Models.Recipes;
//
//    var hits = Hits.FromJson(jsonString);

namespace VLC.Models.Recipes
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel.DataAnnotations;
    using System.ComponentModel.DataAnnotations.Schema;
    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Hits
    {
        [Key]
        public int Id { get; set; }
        [JsonProperty("from")]
        public long From { get; set; }

        [JsonProperty("to")]
        public long To { get; set; }

        [JsonProperty("count")]
        public long Count { get; set; }

        [JsonProperty("_links")]
        public HitsLinks Links { get; set; }

        [JsonProperty("hits")]
        public List<Hit> HitsList { get; set; } = new List<Hit>();
    }

    public partial class Hit
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("recipe")]
        public Recipe Recipe { get; set; }

        [JsonProperty("_links")]
        public HitLinks Links { get; set; }
    }

    public partial class HitLinks
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("self")]
        public Next Self { get; set; }
    }

    public partial class Next
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("href")]
        public Uri Href { get; set; }

        [JsonProperty("title")]
        public Title Title { get; set; }
    }

    public partial class Recipe
    {
        //public int Id { get; set; }

        [JsonProperty("uri")]
        public Uri Uri { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("image")]
        public Uri Image { get; set; }

        [JsonProperty("images")]
        public Images Images { get; set; }

        [JsonProperty("source")]
        public string Source { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }

        [JsonProperty("shareAs")]
        public Uri ShareAs { get; set; }

        [JsonProperty("yield")]
        public long Yield { get; set; }

        [JsonProperty("dietLabels")]
        [NotMapped]
        public List<DietLabel> DietLabels { get; set; }

        [JsonProperty("health")]
        [NotMapped]
        public List<HealthLabel> HealthLabels { get; set; }

        [JsonProperty("cautions")]
        [NotMapped]
        public List<string> Cautions { get; set; }

        [JsonProperty("ingredientLines")]
        [NotMapped]
        public List<string> IngredientLines { get; set; }

        [JsonProperty("ingredients")]
        public List<Ingredient> Ingredients { get; set; }

        [JsonProperty("calories")]
        public double Calories { get; set; }

        [JsonProperty("totalWeight")]
        public double TotalWeight { get; set; }

        [JsonProperty("totalTime")]
        public long TotalTime { get; set; }

        [JsonProperty("cuisineType")]
        [NotMapped]
        public List<string> CuisineType { get; set; }

        [JsonProperty("mealType")]
        [NotMapped]
        public List<MealType> MealType { get; set; }

        [JsonProperty("dishType")]
        [NotMapped]
        public List<DishType> DishType { get; set; }

        [JsonProperty("totalNutrients")]
        [NotMapped]
        public Dictionary<string, Total> TotalNutrients { get; set; }

        [JsonProperty("totalDaily")]
        [NotMapped]
        public Dictionary<string, Total> TotalDaily { get; set; }

        [JsonProperty("digest")]
        [NotMapped]
        public List<Digest> Digest { get; set; }
    }

    public partial class Digest
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("tag")]
        public string Tag { get; set; }

        [JsonProperty("schemaOrgTag")]
        public SchemaOrgTag? SchemaOrgTag { get; set; }

        [JsonProperty("total")]
        public double Total { get; set; }

        [JsonProperty("hasRDI")]
        public bool HasRdi { get; set; }

        [JsonProperty("daily")]
        public double Daily { get; set; }

        [JsonProperty("unit")]
        public Unit Unit { get; set; }

        [JsonProperty("sub", NullValueHandling = NullValueHandling.Ignore)]
        public Digest[] Sub { get; set; }
    }

    public partial class Images
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("THUMBNAIL")]
        public Large Thumbnail { get; set; }

        [JsonProperty("SMALL")]
        public Large Small { get; set; }

        [JsonProperty("REGULAR")]
        public Large Regular { get; set; }

        [JsonProperty("LARGE", NullValueHandling = NullValueHandling.Ignore)]
        public Large Large { get; set; }
    }

    public partial class Large
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }

        [JsonProperty("width")]
        public long Width { get; set; }

        [JsonProperty("height")]
        public long Height { get; set; }
    }

    public partial class Ingredient
    {
        //public int Id { get; set; }

        [JsonProperty("text")]
        public string Text { get; set; }

        [JsonProperty("quantity")]
        public double Quantity { get; set; }

        [JsonProperty("measure")]
        public string Measure { get; set; }

        [JsonProperty("food")]
        public string Food { get; set; }

        [JsonProperty("weight")]
        public double Weight { get; set; }

        [JsonProperty("foodCategory")]
        public string FoodCategory { get; set; }

        [JsonProperty("foodId")]
        public string FoodId { get; set; }

        [JsonProperty("image")]
        public Uri Image { get; set; }
    }

    public partial class Total
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("label")]
        public string Label { get; set; }

        [JsonProperty("quantity")]
        public double Quantity { get; set; }

        [JsonProperty("unit")]
        public Unit Unit { get; set; }
    }

    public partial class HitsLinks
    {
        [Key]
        public int Id { get; set; }

        [JsonProperty("next")]
        public Next Next { get; set; }
    }


    // TODO: Complete enums
    public enum Title { NextPage, Self };

    public enum Caution { Eggs, Fodmap, Milk, Soy, Sulfites };

    public enum CuisineType { American, Asian, British, Caribbean, CentralEurope, Chinese, EasternEurope, French, Indian, Italian, Japanese, Kosher, Mediterranean, Mexican, MiddleEastern, Nordic, SouthAmerican, SouthEastAsian };

    public enum DietLabel { Balanced, HighFiber, HighProtein, LowCarb, LowFat, LowSodium };

    public enum SchemaOrgTag { CarbohydrateContent, CholesterolContent, FatContent, FiberContent, ProteinContent, SaturatedFatContent, SodiumContent, SugarContent, TransFatContent };

    public enum Unit { Empty, G, Kcal, Mg, Μg };

    public enum DishType { AlcoholCocktail, BiscuitsAndCookies, Bread, Cereals, CondimentsAndSauces, Desserts, Drinks, Egg,
        IceCreamAndCustard, MainCourse, Pancake, Pasta, Pastry, PiesAndTarts, Pizza, Preps, Preserve, Salad, Sandwiches, SeaFood,
        SideDish, Soup, SpecialOccasions, Starter, Sweets };

    public enum MealType { Breakfast, Brunch, LunchDinner, Snack, Teatime };

    public enum HealthLabel { AlcoholCocktail, AlcoholFree, CeleryFree, CrustaceanFree, DairyFree, Dash, EggFree, FishFree, FodmapFree,
    GlutenFree, ImmunoSupportive, KetoFriendly, KidneyFriendly, Kosher, LowFatAbs, LowPotassium, LowSugar, LupineFree, Mediterranean, MolluskFree, MustardFree,
    NoOilAdded, Paleo, PeanutFree, Pescatarian, PorkFree, RedMeatFree, SesameFree, ShellfishFree, SoyFree, SugarConscious, SulfiteFree, TreeNutFree, Vegan, Vegetarian, WheatFree };

    public partial class Hits
    {
        public static Hits FromJson(string json) => JsonConvert.DeserializeObject<Hits>(json, VLC.Models.Recipes.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Hits self) => JsonConvert.SerializeObject(self, VLC.Models.Recipes.Converter.Settings);
    }


    // TODO: Build this class to service all enums 
    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                TitleConverter.Singleton,
                CautionConverter.Singleton,
                CuisineTypeConverter.Singleton,
                DietLabelConverter.Singleton,
                SchemaOrgTagConverter.Singleton,
                UnitConverter.Singleton,
                DishTypeConverter.Singleton,
                MealTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class TitleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Title) || t == typeof(Title?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Next page":
                    return Title.NextPage;
                case "Self":
                    return Title.Self;
            }
            throw new Exception("Cannot unmarshal type Title");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Title)untypedValue;
            switch (value)
            {
                case Title.NextPage:
                    serializer.Serialize(writer, "Next page");
                    return;
                case Title.Self:
                    serializer.Serialize(writer, "Self");
                    return;
            }
            throw new Exception("Cannot marshal type Title");
        }

        public static readonly TitleConverter Singleton = new TitleConverter();
    }

    internal class CautionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Caution) || t == typeof(Caution?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Eggs":
                    return Caution.Eggs;
                case "FODMAP":
                    return Caution.Fodmap;
                case "Milk":
                    return Caution.Milk;
                case "Soy":
                    return Caution.Soy;
                case "Sulfites":
                    return Caution.Sulfites;
            }
            throw new Exception("Cannot unmarshal type Caution");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Caution)untypedValue;
            switch (value)
            {
                case Caution.Eggs:
                    serializer.Serialize(writer, "Eggs");
                    return;
                case Caution.Fodmap:
                    serializer.Serialize(writer, "FODMAP");
                    return;
                case Caution.Milk:
                    serializer.Serialize(writer, "Milk");
                    return;
                case Caution.Soy:
                    serializer.Serialize(writer, "Soy");
                    return;
                case Caution.Sulfites:
                    serializer.Serialize(writer, "Sulfites");
                    return;
            }
            throw new Exception("Cannot marshal type Caution");
        }

        public static readonly CautionConverter Singleton = new CautionConverter();
    }


    internal class HealthLabelsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HealthLabel) || t == typeof(HealthLabel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alcohol-cocktail":
                    return HealthLabel.AlcoholCocktail;
                case "alcohol-Free":
                    return HealthLabel.AlcoholFree;
                case "celery-free":
                    return HealthLabel.CeleryFree;
                case "crustacean-free":
                    return HealthLabel.CrustaceanFree;
                case "dairy-free":
                    return HealthLabel.DairyFree;
                case "DASH":
                    return HealthLabel.Dash;
                case "egg-free":
                    return HealthLabel.EggFree;
                case "fish-free":
                    return HealthLabel.FishFree;
                case "fodmap-free":
                    return HealthLabel.FodmapFree;
                case "gluten-free":
                    return HealthLabel.GlutenFree;
                case "immuno-supportive":
                    return HealthLabel.ImmunoSupportive;
                case "keto-friendly":
                    return HealthLabel.KetoFriendly;
                case "kidney-friendly":
                    return HealthLabel.KidneyFriendly;
                case "kosher":
                    return HealthLabel.Kosher;
                case "low-fat-abs":
                    return HealthLabel.LowFatAbs;
                case "low-potassium":
                    return HealthLabel.LowPotassium;
                case "low-sugar":
                    return HealthLabel.LowSugar;
                case "lupine-free":
                    return HealthLabel.LupineFree;
                case "Mediterranean":
                    return HealthLabel.Mediterranean;
                case "mollusk-free":
                    return HealthLabel.MolluskFree;
                case "mustard-free":
                    return HealthLabel.MustardFree;
                case "no-oil-added":
                    return HealthLabel.NoOilAdded;
                case "paleo":
                    return HealthLabel.Paleo;
                case "peanut-free":
                    return HealthLabel.PeanutFree;
                case "pescatarian":
                    return HealthLabel.Pescatarian;
                case "pork-free":
                    return HealthLabel.PorkFree;
                case "red-meat-free":
                    return HealthLabel.RedMeatFree;
                case "sesame-free":
                    return HealthLabel.SesameFree;
                case "shellfish-free":
                    return HealthLabel.ShellfishFree;
                case "soy-free":
                    return HealthLabel.SoyFree;
                case "sugar-conscious":
                    return HealthLabel.SugarConscious;
                case "sulfite-free":
                    return HealthLabel.SulfiteFree;
                case "tree-nut-free":
                    return HealthLabel.TreeNutFree;
                case "vegan":
                    return HealthLabel.Vegan;
                case "vegetarian":
                    return HealthLabel.Vegetarian;
                case "wheat-free":
                    return HealthLabel.WheatFree;

            }
            throw new Exception("Cannot unmarshal type CuisineType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HealthLabel)untypedValue;
            switch (value)
            {
                case HealthLabel.AlcoholCocktail:
                    serializer.Serialize(writer, "alcohol-cocktail");
                    return;
                case HealthLabel.AlcoholFree:
                    serializer.Serialize(writer, "alcohol-free");
                    return;
                case HealthLabel.CeleryFree:
                    serializer.Serialize(writer, "celery-free");
                    return;
                case HealthLabel.CrustaceanFree:
                    serializer.Serialize(writer, "crustacean-free");
                    return;
                case HealthLabel.DairyFree:
                    serializer.Serialize(writer, "dairy-free");
                    return;
                case HealthLabel.Dash:
                    serializer.Serialize(writer, "DASH");
                    return;
                case HealthLabel.EggFree:
                    serializer.Serialize(writer, "egg-free");
                    return;
                case HealthLabel.FishFree:
                    serializer.Serialize(writer, "fish-free");
                    return;
                case HealthLabel.FodmapFree:
                    serializer.Serialize(writer, "fodmap-free");
                    return;
                case HealthLabel.GlutenFree:
                    serializer.Serialize(writer, "gluten-free");
                    return;
                case HealthLabel.ImmunoSupportive:
                    serializer.Serialize(writer, "immuno-supportive");
                    return;
                case HealthLabel.KetoFriendly:
                    serializer.Serialize(writer, "keto-friendly");
                    return;
                case HealthLabel.KidneyFriendly:
                    serializer.Serialize(writer, "kidney-friendly");
                    return;
                case HealthLabel.Kosher:
                    serializer.Serialize(writer, "kosher");
                    return;
                case HealthLabel.LowFatAbs:
                    serializer.Serialize(writer, "low-fat-abs");
                    return;
                case HealthLabel.LowPotassium:
                    serializer.Serialize(writer, "low-potassium");
                    return;
                case HealthLabel.LowSugar:
                    serializer.Serialize(writer, "low-sugar");
                    return;
                case HealthLabel.LupineFree:
                    serializer.Serialize(writer, "lupine-free");
                    return;
                case HealthLabel.Mediterranean:
                    serializer.Serialize(writer, "Mediterranean");
                    return;
                case HealthLabel.MolluskFree:
                    serializer.Serialize(writer, "mollusk-free");
                    return;
                case HealthLabel.MustardFree:
                    serializer.Serialize(writer, "mustard-free");
                    return;
                case HealthLabel.NoOilAdded:
                    serializer.Serialize(writer, "no-oil-added");
                    return;
                case HealthLabel.Paleo:
                    serializer.Serialize(writer, "paleo");
                    return;
                case HealthLabel.PeanutFree:
                    serializer.Serialize(writer, "peanut-free");
                    return;
                case HealthLabel.Pescatarian:
                    serializer.Serialize(writer, "pescatarian");
                    return;
                case HealthLabel.PorkFree:
                    serializer.Serialize(writer, "pork-free");
                    return;
                case HealthLabel.RedMeatFree:
                    serializer.Serialize(writer, "red-meat-free");
                    return;
                case HealthLabel.SesameFree:
                    serializer.Serialize(writer, "sesame-free");
                    return;
                case HealthLabel.ShellfishFree:
                    serializer.Serialize(writer, "shellfish-free");
                    return;
                case HealthLabel.SoyFree:
                    serializer.Serialize(writer, "soy-free");
                    return;
                case HealthLabel.SugarConscious:
                    serializer.Serialize(writer, "sugar-conscious");
                    return;
                case HealthLabel.SulfiteFree:
                    serializer.Serialize(writer, "sulfite-free");
                    return;
                case HealthLabel.TreeNutFree:
                    serializer.Serialize(writer, "tree-nut-free");
                    return;
                case HealthLabel.Vegan:
                    serializer.Serialize(writer, "vegan");
                    return;
                case HealthLabel.Vegetarian:
                    serializer.Serialize(writer, "vegetarian");
                    return;
                case HealthLabel.WheatFree:
                    serializer.Serialize(writer, "wheat-free");
                    return;



            }
            throw new Exception("Cannot marshal type CuisineType");
        }

        public static readonly HealthLabelsConverter Singleton = new HealthLabelsConverter();
    }





    internal class CuisineTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CuisineType) || t == typeof(CuisineType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "American":
                    return CuisineType.American;
                case "Asian":
                    return CuisineType.Asian;
                case "British":
                    return CuisineType.British;
                case "Caribbean":
                    return CuisineType.Caribbean;
                case "Central Europe":
                    return CuisineType.CentralEurope;
                case "Chinese":
                    return CuisineType.Chinese;
                case "Eastern Europe":
                    return CuisineType.EasternEurope;
                case "French":
                    return CuisineType.French;
                case "Indian":
                    return CuisineType.Indian;
                case "Italian":
                    return CuisineType.Italian;
                case "Japanese":
                    return CuisineType.Japanese;
                case "Kosher":
                    return CuisineType.Kosher;
                case "Mediterranean":
                    return CuisineType.Mediterranean;
                case "Mexican":
                    return CuisineType.Mexican;
                case "Middle Eastern":
                    return CuisineType.MiddleEastern;
                case "Nordic":
                    return CuisineType.Nordic;
                case "South American":
                    return CuisineType.SouthAmerican;
                case "South East Asian":
                    return CuisineType.SouthEastAsian;
                
            }
            throw new Exception("Cannot unmarshal type CuisineType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CuisineType)untypedValue;
            switch (value)
            {
                case CuisineType.American:
                    serializer.Serialize(writer, "American");
                    return;
                case CuisineType.Asian:
                    serializer.Serialize(writer, "Asian");
                    return;
                case CuisineType.British:
                    serializer.Serialize(writer, "British");
                    return;
                case CuisineType.Caribbean:
                    serializer.Serialize(writer, "Caribbean");
                    return;
                case CuisineType.CentralEurope:
                    serializer.Serialize(writer, "Central Europe");
                    return;
                case CuisineType.Chinese:
                    serializer.Serialize(writer, "Chinese");
                    return;
                case CuisineType.EasternEurope:
                    serializer.Serialize(writer, "Eastern Europe");
                    return;
                case CuisineType.French:
                    serializer.Serialize(writer, "French");
                    return;
                case CuisineType.Indian:
                    serializer.Serialize(writer, "Indian");
                    return;
                case CuisineType.Italian:
                    serializer.Serialize(writer, "Italian");
                    return;
                case CuisineType.Japanese:
                    serializer.Serialize(writer, "Japanese");
                    return;
                case CuisineType.Kosher:
                    serializer.Serialize(writer, "Kosher");
                    return;
                case CuisineType.Mediterranean:
                    serializer.Serialize(writer, "Mediterranean");
                    return;
                case CuisineType.Mexican:
                    serializer.Serialize(writer, "Mexican");
                    return;
                case CuisineType.MiddleEastern:
                    serializer.Serialize(writer, "Middle Eastern");
                    return;
                case CuisineType.Nordic:
                    serializer.Serialize(writer, "Nordic");
                    return;
                case CuisineType.SouthAmerican:
                    serializer.Serialize(writer, "South American");
                    return;
                case CuisineType.SouthEastAsian:
                    serializer.Serialize(writer, "South East Asian");
                    return;
            }
            throw new Exception("Cannot marshal type CuisineType");
        }

        public static readonly CuisineTypeConverter Singleton = new CuisineTypeConverter();
    }

    internal class DietLabelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DietLabel) || t == typeof(DietLabel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Balanced":
                    return DietLabel.Balanced;
                case "High-Fiber":
                    return DietLabel.HighFiber;
                case "High-Protein":
                    return DietLabel.HighProtein;
                case "Low-Carb":
                    return DietLabel.LowCarb;
                case "Low-Fat":
                    return DietLabel.LowFat;
                case "Low-Sodium":
                    return DietLabel.LowSodium;
            }
            throw new Exception("Cannot unmarshal type DietLabel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DietLabel)untypedValue;
            switch (value)
            {
                case DietLabel.Balanced:
                    serializer.Serialize(writer, "Balanced");
                    return;
                case DietLabel.HighFiber:
                    serializer.Serialize(writer, "High-Fiber");
                    return;
                case DietLabel.HighProtein:
                    serializer.Serialize(writer, "High-Protein");
                    return;
                case DietLabel.LowCarb:
                    serializer.Serialize(writer, "Low-Carb");
                    return;
                case DietLabel.LowFat:
                    serializer.Serialize(writer, "Low-Fat");
                    return;
                case DietLabel.LowSodium:
                    serializer.Serialize(writer, "Low-Sodium");
                    return;
            }
            throw new Exception("Cannot marshal type DietLabel");
        }

        public static readonly DietLabelConverter Singleton = new DietLabelConverter();
    }

    internal class SchemaOrgTagConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SchemaOrgTag) || t == typeof(SchemaOrgTag?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "carbohydrateContent":
                    return SchemaOrgTag.CarbohydrateContent;
                case "cholesterolContent":
                    return SchemaOrgTag.CholesterolContent;
                case "fatContent":
                    return SchemaOrgTag.FatContent;
                case "fiberContent":
                    return SchemaOrgTag.FiberContent;
                case "proteinContent":
                    return SchemaOrgTag.ProteinContent;
                case "saturatedFatContent":
                    return SchemaOrgTag.SaturatedFatContent;
                case "sodiumContent":
                    return SchemaOrgTag.SodiumContent;
                case "sugarContent":
                    return SchemaOrgTag.SugarContent;
                case "transFatContent":
                    return SchemaOrgTag.TransFatContent;
            }
            throw new Exception("Cannot unmarshal type SchemaOrgTag");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SchemaOrgTag)untypedValue;
            switch (value)
            {
                case SchemaOrgTag.CarbohydrateContent:
                    serializer.Serialize(writer, "carbohydrateContent");
                    return;
                case SchemaOrgTag.CholesterolContent:
                    serializer.Serialize(writer, "cholesterolContent");
                    return;
                case SchemaOrgTag.FatContent:
                    serializer.Serialize(writer, "fatContent");
                    return;
                case SchemaOrgTag.FiberContent:
                    serializer.Serialize(writer, "fiberContent");
                    return;
                case SchemaOrgTag.ProteinContent:
                    serializer.Serialize(writer, "proteinContent");
                    return;
                case SchemaOrgTag.SaturatedFatContent:
                    serializer.Serialize(writer, "saturatedFatContent");
                    return;
                case SchemaOrgTag.SodiumContent:
                    serializer.Serialize(writer, "sodiumContent");
                    return;
                case SchemaOrgTag.SugarContent:
                    serializer.Serialize(writer, "sugarContent");
                    return;
                case SchemaOrgTag.TransFatContent:
                    serializer.Serialize(writer, "transFatContent");
                    return;
            }
            throw new Exception("Cannot marshal type SchemaOrgTag");
        }

        public static readonly SchemaOrgTagConverter Singleton = new SchemaOrgTagConverter();
    }

    internal class UnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Unit) || t == typeof(Unit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "%":
                    return Unit.Empty;
                case "g":
                    return Unit.G;
                case "kcal":
                    return Unit.Kcal;
                case "mg":
                    return Unit.Mg;
                case "µg":
                    return Unit.Μg;
            }
            throw new Exception("Cannot unmarshal type Unit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Unit)untypedValue;
            switch (value)
            {
                case Unit.Empty:
                    serializer.Serialize(writer, "%");
                    return;
                case Unit.G:
                    serializer.Serialize(writer, "g");
                    return;
                case Unit.Kcal:
                    serializer.Serialize(writer, "kcal");
                    return;
                case Unit.Mg:
                    serializer.Serialize(writer, "mg");
                    return;
                case Unit.Μg:
                    serializer.Serialize(writer, "µg");
                    return;
            }
            throw new Exception("Cannot marshal type Unit");
        }

        public static readonly UnitConverter Singleton = new UnitConverter();
    }

    internal class DishTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DishType) || t == typeof(DishType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "alcohol cocktail":
                    return DishType.AlcoholCocktail;
                case "biscuits and cookies":
                    return DishType.BiscuitsAndCookies;
                case "bread":
                    return DishType.Bread;
                case "cereals":
                    return DishType.Cereals;
                case "condiments and sauces":
                    return DishType.CondimentsAndSauces;
                case "desserts":
                    return DishType.Desserts;
                case "drinks":
                    return DishType.Drinks;
                case "egg":
                    return DishType.Egg;
                case "ice cream and custard":
                    return DishType.IceCreamAndCustard;
                case "main course":
                    return DishType.MainCourse;
                case "pancake":
                    return DishType.Pancake;
                case "pasta":
                    return DishType.Pasta;
                case "pastry":
                    return DishType.Pastry;
                case "pies and tarts":
                    return DishType.PiesAndTarts;
                case "pizza":
                    return DishType.Pizza;
                case "preps":
                    return DishType.Preps;
                case "preserve":
                    return DishType.Preserve;
                case "salad":
                    return DishType.Salad;
                case "sandwiches":
                    return DishType.Sandwiches;
                case "seafood":
                    return DishType.SeaFood;
                case "side Dish":
                    return DishType.SideDish;
                case "soup":
                    return DishType.Soup;
                case "special occasions":
                    return DishType.SpecialOccasions;
                case "starter":
                    return DishType.Starter;
                case "sweets":
                    return DishType.Sweets;
            }
            throw new Exception("Cannot unmarshal type DishType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DishType)untypedValue;
            switch (value)
            {
                case DishType.AlcoholCocktail:
                    serializer.Serialize(writer, "alcohol cocktail");
                    return;
                case DishType.BiscuitsAndCookies:
                    serializer.Serialize(writer, "biscuits and cookies");
                    return;
                case DishType.Bread:
                    serializer.Serialize(writer, "bread");
                    return;
                case DishType.Cereals:
                    serializer.Serialize(writer, "cereals");
                    return;
                case DishType.CondimentsAndSauces:
                    serializer.Serialize(writer, "condiments and sauces");
                    return;
                case DishType.Desserts:
                    serializer.Serialize(writer, "desserts");
                    return;
                case DishType.Drinks:
                    serializer.Serialize(writer, "drinks");
                    return;
                case DishType.Egg:
                    serializer.Serialize(writer, "egg");
                    return;
                case DishType.IceCreamAndCustard:
                    serializer.Serialize(writer, "ice cream and custard");
                    return;
                case DishType.MainCourse:
                    serializer.Serialize(writer, "main course");
                    return;
                case DishType.Pancake:
                    serializer.Serialize(writer, "pancake");
                    return;
                case DishType.Pasta:
                    serializer.Serialize(writer, "pasta");
                    return;
                case DishType.Pastry:
                    serializer.Serialize(writer, "pastry");
                    return;
                case DishType.PiesAndTarts:
                    serializer.Serialize(writer, "pies and tarts");
                    return;
                case DishType.Pizza:
                    serializer.Serialize(writer, "pizza");
                    return;
                case DishType.Preps:
                    serializer.Serialize(writer, "preps");
                    return;
                case DishType.Preserve:
                    serializer.Serialize(writer, "preserve");
                    return;
                case DishType.Salad:
                    serializer.Serialize(writer, "salad");
                    return;
                case DishType.Sandwiches:
                    serializer.Serialize(writer, "sandwiches");
                    return;
                case DishType.SeaFood:
                    serializer.Serialize(writer, "seafood");
                    return;
                case DishType.SideDish:
                    serializer.Serialize(writer, "side dish");
                    return;
                case DishType.Soup:
                    serializer.Serialize(writer, "soup");
                    return;
                case DishType.SpecialOccasions:
                    serializer.Serialize(writer, "special occasions");
                    return;
                case DishType.Starter:
                    serializer.Serialize(writer, "starter");
                    return;
                case DishType.Sweets:
                    serializer.Serialize(writer, "sweets");
                    return;
            }
            throw new Exception("Cannot marshal type DishType");
        }

        public static readonly DishTypeConverter Singleton = new DishTypeConverter();
    }

    internal class MealTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MealType) || t == typeof(MealType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "breakfast":
                    return MealType.Breakfast;
                case "brunch":
                    return MealType.Brunch;
                case "lunch/dinner":
                    return MealType.LunchDinner;
                case "snack":
                    return MealType.Snack;
                case "teatime":
                    return MealType.Teatime;
            }
            throw new Exception("Cannot unmarshal type MealType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MealType)untypedValue;
            switch (value)
            {
                case MealType.Breakfast:
                    serializer.Serialize(writer, "breakfast");
                    return;
                case MealType.Brunch:
                    serializer.Serialize(writer, "brunch");
                    return;
                case MealType.LunchDinner:
                    serializer.Serialize(writer, "lunch/dinner");
                    return;
                case MealType.Snack:
                    serializer.Serialize(writer, "snack");
                    return;
                case MealType.Teatime:
                    serializer.Serialize(writer, "teatime");
                    return;
            }
            throw new Exception("Cannot marshal type MealType");
        }

        public static readonly MealTypeConverter Singleton = new MealTypeConverter();
    }
}
